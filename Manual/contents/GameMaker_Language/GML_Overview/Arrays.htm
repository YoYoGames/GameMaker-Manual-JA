<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>アレイ（配列</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining Arrays" />
  <meta name="rh-index-keywords" content="Arrays" />
  <meta name="search-keywords" content="Arrays" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>アレイ（配列</h1>
  <p>配列は非常に便利なもので、ゲームを作る上では欠かせないものです。本来は複数の値を「リスト」として保持できる変数の一種です -- 次のコードを考えてみてください。</p>
  <p class="code">numbers = [ 0, 1, 2, 3, 4, 5 ];<br />
    <br />
    fruits = [ &quot;Apples&quot;, &quot;Oranges&quot;, &quot;Mangoes&quot; ];
  </p>
  <p><span class="inline2">item, item, item] の</span>構文で、変数に格納される配列を作成しています。配列に格納された項目は、後でその変数を通して <span class="inline">0</span> から始まる整数値でアクセスすることができます。この整数値は<span class="inline2">[]</span>ブラケットで囲まれています。</p>
  <p class="code">first_fruit = fruits[ 0 ];<br />
    second_fruit = fruits[ 1 ];<br />
    // ...and so on.</p>
  <p><label for="aone">基本的な配列は1<strong>次元</strong>ですが、2次元以上の配列も可能です。以下の章では、この2種類の配列について説明します。</label></p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">1次元配列</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">その前に、配列とは何か、どのような構造になっているかを明らかにしておきましょう。配列とは、変数に代入される<a href="Data_Types.htm">データ型の</a>ことで、1つの値だけでなく、複数の値を格納することができます。下の図は、基本的な配列の模式図です。</p>
    <p class="dropspot"><img class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/1DArrayExample.png" /></p>
    <p class="dropspot">これは<strong>1D</strong>（1次元）配列と呼ばれ、ご覧のように変数&quot;<span class="inline">a</span>&quot;に格納され、複数の値が格納されています。この配列にアクセスするには、次のような操作を行います。</p>
    <p class="code">var _val = a[0];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">上記のコードでは、配列 &quot;<span class="inline">a</span>&quot; の位置 0 から値を取得し、コンソールに出力しています。上の画像に示されている配列の内容からすると、125 と出力されることになります。もし、次のようにしたら</p>
    <p class="code">var _val = a[3];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">出力には、「Hi!</p>
    <p class="dropspot">ご覧のように、配列に変数名を与え、さらに角括弧内に値を与えています。 <span class="inline">[]</span> 、値は配列の中でデータを取得する位置です。つまり、配列とは値を格納するスロットをいくつも持つ容器であり、容器内の各位置にはそれを識別するための特定の番号があり、それを <span class="inline">[]</span> に記述しています。配列の内容は<b>常に 0 から始まり</b>、<i>決して負には</i>ならないことに注意してください<em>!</em></p>
    <h3 class="dropspot">       配列の作成</h3>
    <p class="dropspot">配列のデータをチェックする方法は紹介しましたが、そもそも配列はどのように作成するのでしょうか。まず、配列を使う前に<i>初期</i>化しないと<span data-keyref="GameMaker Name">GameMakerは</span>エラーになります。配列の初期化とは、配列の各スロットに初期値を与えて、プロジェクトコードの他の場所で使用するための準備をすることです。このことは、配列を使う前にある程度の計画を立てる必要があることを意味し、重要なことです。しかし、このように<span class="notranslate">loop</span> を繰り返すことで、配列を初期化することはとても簡単です。</p>
    <p class="code">var i = 9;<br /><br />
      repeat(10)<br />
      {<br />
          array[i] = 0;<br />
          i -= 1;<br />
      }</p>
    <p class="dropspot">この単純なコードは、0から9までの10スロットの配列を0に初期化します。配列は<i>逆に</i>初期化され、最後の値が最初に定義されていることにお気づきでしょう。0 から<em>順に</em>初期化すると、値を追加するたびにメモリを再割り当てしなければなりません（つまり、10 スロットの配列を<span class="notranslate">loop</span> で初期化すると、メモリ割り当てが 10 回変更されることになります）。小さな配列であれば速度の差は無視できますが、大きな配列ではこの方法で可能な限り最適化することが望まれます。</p>
    <p class="note"><b>注</b>：HTML5へのエクスポートは上記のルールの例外であり、ターゲットとする場合は、0から上の連続した順序で配列を初期化する必要があります。</p>
    <p class="dropspot">また、<span class="notranslate">GML</span> 関数 <a href="../GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a>を使えば、固定サイズの配列を初期化することができますし、例えば、値を<em>持たない</em>「空の」配列を作ることもできます。</p>
    <p class="code">my_array = [];</p>
    <p class="dropspot">これにより、<span class="notranslate">GameMaker</span> は、変数 &quot;<span class="inline">my_array</span>&quot; が配列であることを伝え、今後いつでも<a href="../GML_Reference/Variable_Functions/array_push.htm">値を</a>追加することができます。ただし、空の配列にある値にアクセスしようとすると、エラーが発生します。<br></p>
    <p class="dropspot">どの項目を配列に入れるかが既に決まっている場合は、配列を宣言する際に大括弧の間にカンマで区切った値を追加することができます。</p>
    <p class="code">my_array = [&quot;Steve&quot;, 36, &quot;ST-3V3 - Steve Street&quot;];</p>
    <h3 class="dropspot">       配列の境界</h3>
    <p class="dropspot">配列の外側の値にアクセスしようとするとエラーになるので、常に有効な配列の位置にのみアクセスするように注意する必要があります。例えば、これを実行すると、プロジェクトはクラッシュします。</p>
    <p class="code">my_array = array_create(5, 0);<br />
      var _val = my_array[6];</p>
    <p class="dropspot">配列は5つの位置で初期化されただけですが、位置7を取得しようとしました。配列は0から番号が振られるので、 <span class="inline">array[6]</span> は位置7です。したがって、ゲームはエラーを発生しクラッシュします。</p>
    <h3 class="dropspot">       配列の使用</h3>
    <p class="dropspot">さて、配列は実際どのように使うのでしょうか？次の例に示すように、通常の変数の使い方と全く同じです。</p>
    <p class="code">// Add two array values together<br />
      total = array[0] + array[5];<br />
      <br />
      // Check an array value<br />
      if array[9] == 10<br />
      {<br />
          // Do something<br />
      }<br />
      <br />
      // Draw an array value<br />
      draw_text(32, 32, array[3]);
    </p>
    <p class="dropspot">配列には連番が振られているので、初期化したときと同じように、<span class="notranslate">loop</span> 、余計な動作も行えるということです。</p>
    <p class="code">var total = 0;<br />
      <br />
      for (var i = 0; i &lt; 10; ++i)<br />
      {<br />
          total += array[i];<br />
          draw_text(32, 32 + (i * 32), array[i]);<br />
      }<br />
      <br />
      draw_text(32, 32 + (i * 32), total);
    </p>
    <p class="dropspot">上記のコードは、配列にあるすべての値を合計し、それぞれを描画して、最後に合計値を描画します。</p>
    <h3 class="dropspot">       アレイの削除</h3>
    <p class="dropspot">配列について最後に述べておくと、配列を定義している変数に1つの値を「再代入」するだけで、配列を削除することができます。これにより、その配列のすべての位置と値に関連するメモリが解放されます。例えば</p>
    <p class="code">// Create an array<br />for (var i = 9; i &gt; -1; --i)<br />
      {<br />
          a[i] = i;<br />
      }<br />
      <br />
      // Delete the array<br />
      a = -1;
    </p>
    <p class="dropspot"><span class="notranslate">Room</span> インスタンスに配列を作成した場合、インスタンスがゲームから削除されたときに、これらの配列はクリーンアップされる必要はありません。ただし、配列の位置がパーティクルシステム、<span class="notranslate">buffers</span> 、データ構造などの<em>動的</em>アセットへの参照を保持している場合は、配列の削除、インスタンスの破棄、または<span class="notranslate">room</span> の終了前に<em>、</em>これらを破棄する必要があります。</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">多次元配列</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><span style="text-align: justify;">1次元の配列がどういうものかはわかりましたが、<span data-keyref="GameMaker Name">GameMakerでは</span>多次元の配列が可能で、基本的には配列の中に配列がある...という構造になっています。例えば、以下は<strong>2D</strong>（2次元）配列です。</span></p>
    <p class="code">array[0][0] = 5;</p>
    <p class="dropspot">これは、本質的に、配列が実際には様々な1次元配列で構成されていることを<span class="notranslate">GameMaker</span> に伝えているのです。以下はその拡張例です。</p>
    <p class="code">array<strong>[0]</strong>[0] = 0;<br />
      array<strong>[0]</strong>[1] = 1;<br />
      array<strong>[0]</strong>[2] = 2;<br />
      <br />
      array<strong>[1]</strong>[0] = 3;<br />
      array<strong>[1]</strong>[1] = 4;<br />
      <strong></strong>array<strong>[1]</strong>[2] = 5;
    </p>
    <p class="dropspot">上記のコードでは， <span class="inline">array[0]</span> が別の配列を保持しており，<span class="inline">array[1]</span> も同様です．</p>
    <p class="dropspot">多次元配列は、1次元の配列と同じように使用前に初期化する必要があり、実数、<span class="notranslate">strings</span> 、その他の<a href="Data_Types.htm">データ型を</a>変数と同じように保持できます。大量のデータを簡単にアクセスできる方法で保存する必要があるゲームにとって、理想的な候補です（忘れずに、配列を通して簡単に<span class="notranslate">loop</span> できるのです）。</p>
    <p class="dropspot">また、1次元配列を入れ子にすることで、1つの文の中で多次元配列を初期化することができます。</p>
    <p class="code">two_dimensional_array = <br />
      [<br />
          [&quot;Apple&quot;, 10, 2],<br />
          [&quot;Orange&quot;, 5, 2],<br />
          [&quot;Mango&quot;, 15, 4],<br />
          // ...and so on.<br />
      ]</p>
    <p class="dropspot">また、多次元配列は2<em>次元に </em>限らず、 <span class="inline">[n]</span> のような引数を追加するだけで、コードの必要に応じて3次元、4次元、それ以上の次元の配列を持つことができます。</p>
    <p class="code">array[0][0][0] = 1;     // A three dimensional array<br />
      array[0][0][0][0] = 1;  // A four dimensional array<br />
      // etc...</p>
    <p class="dropspot">配列の各次元の長さを変えることができるので、配列の最初の次元の長さは3ですが、2番目の次元のエントリーは、最初の次元の各スロットに対して異なる長さにすることができます。</p>
    <p class="code">array[2][2] = &quot;3&quot;;<br />
      array[2][1] = &quot;2&quot;;<br />
      array[2][0] = &quot;1&quot;;<br />
      <br />
      array[1][3] = &quot;four&quot;;<br />
      array[1][2] = &quot;three&quot;;<br />
      array[1][1] = &quot;two&quot;;<br />
      array[1][0] = &quot;one&quot;;<br />
      <br />
      array[0][1] = 2;<br />
      array[0][0] = 1;
    </p>
    <p class="dropspot">上記のコードでは、 <span class="inline">array[0]</span> が 2 スロット、 <span class="inline">array[1]</span> が 4 スロット、 <span class="inline">array[2]</span> が 3 スロットになります。</p>
    <h3 class="dropspot">       拡張例</h3>
    <p class="dropspot">最後に、実際のゲームでの使い方の例を一つご紹介します。例えば、ゲーム中の4つの地点で、ランダムな値によって4種類の敵を出現させたいとします。この場合、2次元の配列を使用することで、コードを書く手間を省くことができます。</p>
    <p class="dropspot">まず、&quot;controller&quot;<span class="notranslate">object</span> の Create イベントで使用する配列を初期化します (各配列のエントリが何を行うかを示すコメントを使用していることに注意しましょう)。</p>
    <p class="code">enemy[3][2] = 448;       //y position<br />
      enemy[3][1] = 32;        //x position<br />
      enemy[3][0] = obj_Slime; //Object<br />
      enemy[2][2] = 448;<br />
      enemy[2][1] = 608;<br />
      enemy[2][0] = obj_Skeleton;<br />
      enemy[1][2] = 32;<br />
      enemy[1][1] = 608;<br />
      enemy[1][0] = obj_Knight;<br />
      enemy[0][2] = 32;<br />
      enemy[0][1] = 32;<br />
      enemy[0][0] = obj_Ogre;</p>
    <p class="dropspot">これで、インスタンスを生成する<span class="notranslate">objects</span> と、それに対応する<span class="notranslate">room</span> 内の x および y スポーン座標が、すべて配列に格納されました。これは、コントローラ<span class="notranslate">object</span> の別のイベント（たとえば、アラームやキー押下イベント）で、次のように使用することができます。</p>
    <p class="code">//get a random number from 0 to 3, inclusive<br />
      var i = irandom(3);<br />
      <br />
      //Use the array to create the object<br />
      instance_create_layer(enemy[i][1], enemy[i][2], &quot;Enemy_Layer&quot;, enemy[i][0]);
    </p>
    <p class="dropspot">この短いコードで、ゲーム内のランダムな敵を生成します。<span class="notranslate">room</span> 、これは &quot;<span class="inline">if / then / else</span>&quot; 構造体や &quot;<span class="inline">switch</span>&quot; よりもはるかに少ないコードで、配列はすべて create イベントで初期化されるので、プロジェクトの残りのコードに<a class="glossterm" data-glossterm="ハードコード化" href="#">ハードコードされて</a>いないこれらの値を編集して変更することが非常に簡単になります。</p>
  </div>
  <p> </p>
  <h2>関数の引数としての配列</h2>
  <p><a href="Script_Functions.htm">スクリプト関数や</a> <a href="Method_Variables.htm">メソッド変数に</a>引数として配列を渡し、関数内の任意の場所でそれらの配列を変更することができます。この場合、元の配列も同様に変更されます。</p>
  <p>例えば、この関数は、渡された配列の最初の3つの要素を変更するだけです。</p>
  <p class="code">modify_array = function (array)<br />
    {<br />
        array[0] = 2;<br />
        array[1] = 4;<br />
        array[2] = 6;<br />
    }</p>
  <p>これで配列を作成し、この関数に渡すと、配列が修正されます。</p>
  <p class="code">my_array = [100, 4, 214];<br />
    <br />
    modify_array(my_array);<br />
    <br />
    show_debug_message(my_array); // Prints [2, 4, 6];
  </p>
  <p>以前のバージョン（<span class="notranslate">GameMaker</span> ）では、関数内で配列を変更すると、代わりにコピーが作成されたため、このようなことはありませんでした。この<em>非推奨の</em>動作は、必要ならまだ有効にすることができます。 詳細は、以下の &quot;<strong>書き込み時のコピー</strong>&quot; のセクションを参照ください。</p>
  <h2 id="h">コピーオンライト</h2>
  <p>Copy on Writeの動作は非推奨で、<a href="../../Settings/Game_Options.htm">General Game Optionsの</a>「<strong>Enable Copy on Write behaviour for Arrays</strong>」が有効なときのみ使用されます。このセクションでは、このオプションが有効になっているときの配列の動作について説明します。</p>
  <p>前節で説明したように、配列は引数として関数に渡すことができる。そのためには、単に配列変数を指定すればよく（個々の位置や、 <span class="inline">[]</span> の括弧は不要）、配列全体が関数に<b>参照渡し</b>されます。</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    do_something(my_array);
  </p>
  <p>しかし、<strong>Copy on Write</strong>が有効な場合、関数内で配列の値を変更すると、変更内容を含む一時的なコピーが作成されます。元の配列は変更されません。この挙動をCopy on Writeと呼びます。</p>
  <p>関数に渡された元の配列を実際に変更するには、それを返すか、 <span class="inline">@</span> アクセスキーを使用する必要があります。</p>
  <p>例えば、上で呼ばれた<span class="inline2">do_something()</span>という関数は、次のような簡単なことをすることがあります。</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    }</p>
  <p>このとき、<span class="inline2">my_arrayには</span> <span class="inline2">1, 200, 4などの</span>値が格納されるはずで、通常は正しいのですが、<strong>Copy on Writeを</strong>有効にすると、元の配列は影響を受けないままです。</p>
  <p>これを回避するには、関数が変更した配列のコピーを<strong>返し</strong>、それを元の変数に適用すればよいのです。</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    my_array = do_something(my_array);
  </p>
  <p>この関数自体は、変更された配列を返すことになります。</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    <br />
        return array;<br />
    }
  </p>
  <p class="note"><span class="note">注意</span><b> </b>配列の値を変更するのではなく、参照するのであれば、上記のコードは必要ありません。配列を参照することで、配列はコピーされず、パースも高速になります。</p>
  <p>2つ目の解決策は、<span class="inline">@</span> アクセサを使用して配列の値を直接変更することです。これにより、一時的なコピーを作成しなければならないという CPU オーバーヘッドを節約することができます。つまり、関数から配列を返す必要がなく、直接編集することができるのです。</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[@ 1] = 200;<br />
    }</p>
  <p>このアクセサを使用すると、Copy on Write の動作をバイパスして、 参照されている配列を直接変更することができます。これは、オプションを有効にしたまま、特定のステートメントに対して選択的にCopy on Writeを無効にするために使用することができます。</p>
  <p>繰り返しますが、<strong>コピーオンライトが</strong> <strong>無効になって</strong>いる場合（デフォルトおよび推奨オプション）、これらのすべては必要ありません。</p>
  <p>アクセッサの詳細とその動作、配列の例については、次のページを参照してください。</p>
  <ul class="colour">
    <li><a href="Accessors.htm">アクセサー</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">戻る<a href="GML_Overview.htm">GMLの概要</a></div>
        <div style="float:right">次へ<a data-xref="{title}" href="Structs.htm">構造体とコンストラクタ</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Arrays
passing arrays to scripts
deleting arrays
-->
  <!-- TAGS
arrays
-->
</body>
</html>