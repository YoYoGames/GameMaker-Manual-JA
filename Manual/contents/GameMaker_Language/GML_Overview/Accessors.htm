<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>アクセサー</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining the different Accessors" />
  <meta name="rh-index-keywords" content="Accessors" />
  <meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ], [$ ],grid accessor,list accessor,map accessor, struct accessor, array accessor" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>アクセサー</h1>
  <p><span class="notranslate">GameMaker Language</span> (<span class="notranslate">GML</span>) では、<b>アクセッサと</b>呼ばれる論理式を使って、特定の<a href="../GML_Reference/Data_Structures/Data_Structures.htm">データ</a>構造や<a href="Arrays.htm">配列に</a>アクセスすることもできます。これは通常の配列を扱うときと同じような構造になっていますが、最初の引数の前に<em>識別子記号を</em>使い、<span data-keyref="GameMaker Name">GameMakerに</span>（以前に作成した）データ構造または配列リテラルを扱っていることを知らせます。</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">DSリスト [| ]です。</a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">DSリストの</a>構文は以下の通りです。</p>
    <p class="code">list_index[| index]</p>
    <p class="dropspot">そこで、<span class="inline">ds_list_create()</span> を使ってリストを作成した場合、（変数に格納した）リストのインデックスを使って参照することになります。「インデックス」の値は、リスト内で設定または追加する位置を表します。例えば、次のコードは、リストを作成し、10個のエントリーを追加し、各エントリーに0から9までの乱数を設定します。</p>
    <p class="code">ds = ds_list_create();<br />
      var _index = 0;<br />
      repeat(10)<br />
      {<br />
          ds[| _index++] = irandom(9);<br />
      }</p>
    <p class="dropspot">すでに値を持つインデックスに式を使用して参照を追加する場合、リストにさらにインデックスを追加するのではなく、前の値が置き換えられることに注意してください。さらにエントリーを追加するには、ds_listのサイズを知っていて、最後に追加する必要があります。また、参照されているリストのサイズよりも<i>大きな</i>リストインデックスを設定することができ、これはその値を設定すると同時にリストを拡張し、与えられたインデックスまでのリスト内のすべての位置を0として初期化することは注目に値します。</p>
    <p class="dropspot">リスト構造を作り、そこにデータを入れたら、リストから値を取り出すには次のようにします。</p>
    <p class="code">value = ds[| 5];</p>
    <p class="dropspot">上記はポジション5（リストは0から始まるので、6番目のインデックス）から値を取得し、変数に格納します。もし、リストのサイズ以外の位置を指定した場合は、 <span class="inline">undefined</span> という値が返されますが、これは関数 <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">DS Maps [?］</a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DSマップの</a>構文は以下の通りです。</p>
    <p class="code">map_index[? key]</p>
    <p class="dropspot"><span class="inline">ds_map_create()</span> でマップを作成した後、変数に格納したマップインデックスを使用して参照する。&quot;key&quot; の値は、設定または取得するマップキーである。たとえば、次のコードはマップを作成し、この構文を使っていくつかの項目を追加しています。</p>
    <p class="code">ds = ds_map_create();<br />
      ds[? &quot;Name&quot;] = &quot;Hamish&quot;;<br />
      ds[? &quot;Company&quot;] = &quot;MacSeweeny Games&quot;;<br />
      ds[? &quot;Game&quot;] = &quot;Catch The Haggis&quot;;</p>
    <p class="dropspot">なお、追加しようとするキーと同じ値がすでにマップに含まれている場合は、新しい値で重複したキーは作成されず、以前の値が置き換えられることになります。</p>
    <p class="dropspot">マップ構造を作成し、データを入れたら、特定のマップキーから値を取得するために、次のようなコードを作成します。</p>
    <p class="code">value = ds[? &quot;Name&quot;];</p>
    <p class="dropspot">上記は、キー &quot;Name&quot; から値を取得して変数に格納しますが、与えられたキーがDSマップに存在しない場合、返される値は <span class="inline">undefined</span> となることに注意してください。これは、以下の関数で確認できる。 <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">DSグリッド[# ]について</a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot"><a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">DSグリッドの</a>構文は以下の通りです。</p>
    <p class="code">grid_index[# xpos, ypos]</p>
    <p class="dropspot"><span class="inline">ds_grid_create()</span> 関数でグリッドを作成したら、変数に格納したグリッドのインデックスを使って、「xpos」「ypos」をグリッド内の位置にして、値を取得したり設定したりすることになります。たとえば、次のコードは、グリッドを作成し、0にクリアしてから、いくつかの項目を追加しています。</p>
    <p class="code">ds = ds_grid_create();<br />
      ds_grid_clear(ds, 0);<br />
      var _gw = ds_grid_width(ds) - 1;<br />
      var _gh = ds_grid_height(ds) - 1;<br />
      repeat(10)<br />
      {<br />
          var _xx = irandom(_gw);<br />
          var _yy = irandom(_gh);<br />
          if (ds[# _xx, _yy] == 0)<br />
          {<br />
              ds[# _xx, _yy] = 1;<br />
          }<br />
      }</p>
    <p class="dropspot">グリッド構造を作り、データを入れたら、特定のグリッドの位置から値を取得するために、次のような操作を行います。</p>
    <p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p>
    <p class="dropspot">上記は、与えられたds_gridからマウス位置を元に値を取得します（正しい位置を得るために<span class="notranslate">room</span> の「セル」幅で割ります）。もしグリッドの境界の外側の位置を指定した場合は、 <span class="inline">undefined</span> という値が返されます。これは関数 <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#">配列[@]の場合</a></p>
  <div class="droptext" data-targetname="drop-down15">
    <p class="dropspot">このアクセサは、<a href="../../Settings/Game_Options.htm">Copy on Write オプションが</a>有効な場合にのみ使用されます。</p>
    <p class="dropspot">配列にも独自のアクセサがあり、上記のデータ構造のアクセサと同様の働きをします。しかし、配列のアクセサには興味深い性質があり、<a href="Script_Functions.htm">スクリプト関数</a>や <a href="Method_Variables.htm"><span class="notranslate">method</span></a>をコピーする必要はありません。つまり、配列自体は<span class="notranslate">script</span> に<strong>渡さ</strong>れるのではなく、単にデータを取得するために参照されるだけなのです。通常、配列を変更する必要がある場合は、その配列を<span class="notranslate">script</span> に<em>コピー </em>し、コピーした配列を元の配列に戻す（return）必要があります。これは処理のオーバーヘッドが大きくなるため、代わりにアクセサを使用します。アクセサを使用すると、元の配列をコピーすることなく<em>直接 </em>変更することができます。以下の例で、その動作を確認することができます。</p>
    <p class="dropspot">配列の構文は、 <span class="inline">@</span> のアクセサーを使用します。</p>
    <p class="code">array[@ i]</p>
    <p class="dropspot">配列をインスタンスで作成した後、それを参照で<span class="notranslate">script</span> に渡し、アクセサ<span class="inline">@</span> を使って直接変更することができます。たとえば、次のように配列を作成して、ファンクションを呼び出すことができます。</p>
    <p class="code">array[99] = 0;<br />
      array_populate(array);</p>
    <p class="dropspot">関数そのものは、こんな感じでしょうか。</p>
    <p class="code">function array_populate(_array)<br />
      {<br />
          var a = _array; var i = 0;<br />
          repeat(25)<br />
          {<br />
              i = irandom(99);<br />
              while (a[i] != 0)<br />
              {<br />
                  i = irandom(99);<br />
              }<br />
              a[@ i] = 100;<br />
          }<br />
      }</p>
    <p class="dropspot">この関数が行っていることは、配列の25の位置をランダムに選び、選ばれた配列の位置の値を100に設定することだけです。</p>
    <p class="dropspot">もちろん、<strong>Copy on Write</strong>が無効の場合は、 <span class="inline">@</span> のアクセ サは必要ありません。</p>
    <p class="note"><span class="note">注</span>：スクリプト関数で<span class="inline">argument[n]</span> 配列を扱う場合、配列アクセッサ <span class="inline">@</span> は使用できません。</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">構造体 [$ ]です。</a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot"><span><a href="Structs.htm">構造体の</a>構文は次のとおりです。</span></p>
    <p class="code">struct[$ &quot;name&quot;]</p>
    <p class="dropspot">このアクセサは基本的に関数<span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> と<a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a></span>のラッパーで<span>あり、DSマップのアクセサと同じように使用</span>します。<span>例えば、<span class="notranslate">struct</span> を作成し、&quot;my_health&quot; という変数から値を取得したい場合、次のようにします。</span></p>
    <p class="code">var _hp = struct[$ &quot;my_health&quot;];</p>
    <p class="dropspot">見ての通り、変数そのものを供給するのではなく、変数と一緒に<em>文字列を</em>供給するのです。もし<span class="notranslate">struct</span> に指定された名前の変数がなければ、アクセサは値として <span class="inline">undefined</span> を返すことに注意してください。</p>
    <p class="dropspot"><span class="notranslate">struct</span> で変数を設定するには、次のようにします。</p>
    <p class="code">struct[$ &quot;my_score&quot;] = 100;</p>
    <p class="dropspot">値の取得と同様に、設定する変数名を<span class="notranslate">string</span> として与えると、その変数に与えられた値が設定される。使用した変数名が<span class="notranslate">struct</span> に存在しない場合、その変数が作成され、指定された値に設定されます。</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>アクセッサの重要な特徴として、アクセッサは<i>連結して</i>使用できることが挙げられます。つまり、いくつかのデータ構造や配列が入れ子になっている場合、入れ子構造の奥にある値にアクセスするために、様々な関数を使う必要がなくなります。例えば、配列があり、その配列の各項目が以下のようなDSリストであるとする。</p>
  <p class="code">array = array_create(3);<br />
    for (var i = 0; i &lt; 3; ++i)<br />
    {<br />
        array[i] = ds_list_create();<br />
        switch(i)<br />
        {<br />
            case 0:<br />
                with (obj_Wall) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 1:<br />
                with (obj_Door) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 2:<br />
                with (obj_Chest) ds_list_add(array[i], id);<br />
            break;<br />
        }<br />
    }
  </p>
  <p>上記のコードでは、3つのアイテムの配列を作成し、それぞれにDSリストを割り当てました。そして、異なるリストに、ゲーム内のさまざまな<span class="notranslate">objects</span> のインスタンスIDを入力しました。さて、リストの1つのIDにアクセスするには、次のようにします。</p>
  <p class="code">var _list = array[0];<br />
    var _id = ds_list_find_value(_list, 0);</p>
  <p>しかし、連鎖したアクセサを使うことで、より少ないコードで、よりクリーンな方法で同じことができます。</p>
  <p class="code">var _id = array[0][| 0];</p>
  <p>このように複数のアクセッサを連鎖させることができ、それらは入れ子構造の各部分に格納された情報へのアクセスを得るために複数の型を持つことができます。以下に、さらにいくつかの例を示します。</p>
  <p class="code">// Access a grid that has been added to a list that is part of a map:<br />
    var _a = data[? &quot;lists&quot;][| 0][# 0, 0];<br />
    <br />
    // Access an array nested in a list from a script and modify it:<br />
    data[| 0][10] = 100;<br />
    <br />
    // Access a map nested in a grid nested in a list nested in an array:<br />
    data[0][| 10][# 3, 4][? &quot;key&quot;] = &quot;hello world&quot;;
  </p>
  <p>連鎖したアクセサを使うことで、よりコンパクトなコードが書けるだけでなく、イテレーション(例) <a href="Language_Features/for.htm"><span class="inline">for</span></a>ループ）などを用いて、よりすっきりと直感的にデータにアクセスすることができます。</p>
  <p>このようにアクセサを使用する場合、配列には常に <span class="inline">@</span> アクセサを使用する必要があります。そうしないと、実行中のアクションに余分なオーバーヘッドを追加することになるからです。上述したように、デフォルトでは配列は関数に参照渡しされ、変更時には「コピーオンライト」動作が使用されます。しかし、配列がチェーンの一部である場合は、チェーンの前の項目がコピーされた配列で更新され、「元の」配列は削除されます。例えば、次のようなことをします。</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][0] = 200;
  </p>
  <p>は、これを行うのと同じ結果を得ることができます。</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][@ 0] = 200;
  </p>
  <p>しかし、2番目の例の方が、最初に配列全体をコピーする不要なオーバーヘッドを伴わずに動作するため、より優れています。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">戻る<a href="GML_Overview.htm">GMLの概要</a></div>
        <div style="float:right">次へ<a data-xref="{title}" href="Language_Features.htm">言語機能</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
accessors
accessor chaining
grid accessor
list accessor
map accessor
struct accessor
array accessor
@
[| ]
[@ ]
[# ]
[? ]
[$ ]
-->
  <!-- TAGS
accessors
-->
</body>
</html>