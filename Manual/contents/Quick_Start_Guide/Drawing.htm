<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>図面</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code to show people how things are drawn." />
  <meta name="rh-index-keywords" content="Quick Start - Drawing" />
  <meta name="search-keywords" content="drawing,draw event,GUI layer" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>図面</h1>
  <p>このセクション（および次の「<a href="Movement_And_Controls.htm">移動と制御</a>」のセクション）は、<span class="notranslate">GML</span> または<span class="notranslate">GML</span> Visual の実用例を提供し、最初のゲームプロジェクトをできるだけ早く開始できるようにすることを目的 としています。できるだけ早く作り始めたいので、あまり深く説明しません。分からないことがあれば、マニュアルの「検索」機能を使って追加情報を探してください。</p>
  <p>このセクションでは、単にテキストや画像として情報を画面に描画することに集中し、さまざまな<strong>描画イベント</strong>、特にメインの<strong>描画</strong>イベントと<strong>GUIイベントの描画について </strong>もう少し説明します（いくつかの例では、他のイベントを追加する必要がありますが、それらについてはその都度説明します）。</p>
  <p><img alt="The Draw Events" class="center" src="../assets/Images/QS_Guide/QS_DrawEvents.png" /></p>
  <p>この先に進む前に、<a href="../Introduction/The_Start_Page.htm">スタート</a>ページから新しいプロジェクト（<span class="notranslate">GML</span> または<span class="notranslate">GML</span> Visual）を作成し、いくつかの<span class="notranslate">sprites</span> と<span class="notranslate">object</span> を追加（または作成）しておくとよいでしょう。<span class="notranslate">sprite</span> のための<span class="notranslate">object</span> として、白い四角形でもかまいません。</p>
  <p>さて、「<a href="Objects_And_Instances.htm">オブジェクトとインスタンス</a>」のセクションで述べたように、もし<span class="notranslate">object</span> に Draw Event を追加しなければ、<span data-keyref="GameMaker Name">GameMaker</span>はデフォルトで描画します。つまり、もし<span class="notranslate">object</span> に<span class="notranslate">sprite</span> が割り当てられれば、この<span class="notranslate">sprite</span> は、追加されたすべてのトランスフォームとともに描画されることになるのです。トランスフォームとはどういう意味でしょうか。各<span class="notranslate">object</span> にはいくつかの組み込み<span class="glossextra">変数が</span>あり、<span class="notranslate">object</span> のインスタンスがデフォルト描画時に<span class="notranslate">sprite</span> をどのように描画するかを制御します。ゲームの実行中にこれらの変数を変更し、<span class="notranslate">sprite</span> の描画方法を変更することができます。</p>
  <p class="note"><strong>注</strong>: インスタンス<span class="notranslate">sprites</span> の変換に使用できるすべてのビルトイン変数の一覧は、<a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/Sprite_Instance_Variables.htm">こちらで</a>ご覧になれます。 <span class="notranslate">GML</span> Visual ユーザーは、これらの変数に影響を与える専用のアクションをいくつか持っています<a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Drawing_Actions.htm">。</a></p>
  <p>いくつかの例を見てみましょう。</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">アルファ（透明度）の変更</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot"><strong>アルファ </strong>値は描画されるものの透明度をコントロールするもので、<span data-keyref="GameMaker Name">GameMaker</span> では <span class="inline">image_alpha</span> という組み込み変数を使って、割り当てられた<span class="notranslate">sprite</span> の透明度を変更することができます。この仕組みを見るには、<span class="notranslate">object</span> を開き（または作成し）、それに<span class="notranslate">sprite</span> を割り当て、<span class="notranslate">object</span> に<strong>Create Event</strong> を与えます。Create Eventに、次の<span class="notranslate">GML</span> VisualまたはGMLを追加するだけです。</p>
    <p class="dropspot"><img alt="GML VisualDraw Example For Transparency" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_1.png" /></p>
    <p class="code">var _val = random(1);
      <br />
      image_alpha = _val;
    </p>
    <p class="dropspot">画像のアルファ値は0から1までの値で計算され、0は完全に透明、1は完全に不透明になります（デフォルトでは1に設定されています）。つまり、この例でやっていることは、画像のアルファ値を0から1までのランダムな10進数で設定することだけです。この<span class="notranslate">object</span> のインスタンスをいくつか<span class="notranslate">room</span> に配置し、<span class="notranslate">IDE</span> の上部にある<strong>再生 </strong>ボタン<img> をクリックします。</p>
    <p class="dropspot"><span class="notranslate">object</span> の各インスタンスは、その<span class="notranslate">sprite</span> を異なる透明度で描画していることがわかるはずです、例えば。</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">カラーブレンドの変更（ティンティング）</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot"><span class="notranslate">object</span> がデフォルトで<span class="notranslate">sprite</span> を描画しているとき、この<span class="notranslate">sprite</span> は実際には色で<strong>ブレンドされて </strong>（または<strong>着色されて</strong>）描画されており、この色の値は組み込み変数 <span class="inline">image_blend</span> に格納されています。デフォルトでは、この色は白です。これは、基本的に、<span class="notranslate">sprite</span> が画面に表示されるときに、色が追加されないことを意味します。しかし、特殊な効果を得るために他の色を使用することができます。例えば、インスタンスが何らかのダメージを受けたことを示すために赤を使用することができます。</p>
    <p class="dropspot">この例では、キーを押している間、<span class="notranslate">sprite</span> で異なる色をブレンドするつもりです。したがって、<span class="notranslate">object</span> を開き（または作成し）、それに<span class="notranslate">sprite</span> を割り当て、<span class="notranslate">object</span> に<strong>キーダウン &lt;Space&gt; イベントを</strong>与える必要があります。</p>
    <p class="dropspot"><img alt="Example Of Sprites Drawn With Different Alpha Values" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_1.png" /></p>
    <p class="dropspot">この Key Down Event に、以下の<span class="notranslate">GML</span> Visual または GML を追加します。</p>
    <p class="dropspot"><img alt="Add Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="code">var _col = choose(c_red, c_green, c_blue, c_yellow, c_fuchsia, c_orange);
      <br />
      image_blend = _col;
    </p>
    <p class="dropspot">この<span class="notranslate">object</span> のインスタンスをいくつか<span class="notranslate">room</span> に配置し、<span class="notranslate">IDE</span> の上部にある再生ボタン<img> をクリックし、<em>Space </em>キーを押しながら離すテストをしてみてください。キーを押している間、各インスタンスの色が急速に変化し、離すと変化が止まることが確認できるはずです。</p>
    <p class="dropspot"><img alt="GML VisualExample Using Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_2.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">スケールを変える</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot"><span class="notranslate">sprite</span> で変更できるもう一つのプロパティは<strong>スケール </strong>値で、好きなときに大きくしたり小さくしたりすることができます。スケールは、X軸とY軸に沿って、2つの別々の変数、 <span class="inline">image_xscale</span> 変数と <span class="inline">image_yscale</span> 変数によって独立して計算されます。デフォルトでは、これらは1に設定されており、<strong>乗数の</strong>ように動作します。したがって、0.5の値は半分のスケール、2の値は2倍のスケールとなります。</p>
    <p class="note"><strong>重要!こ </strong>れらの変数を使用して割り当てられた<span class="notranslate">sprite</span> のスケールを変更すると、<strong>バウンディング ボックスのサイズもそれに合わせて変更さ</strong>れます。つまり、<span class="notranslate">sprite</span> の衝突検出領域もスケールします。</p>
    <p class="dropspot">この例では、いくつかの簡単な数学を使用して、インスタンスが<span class="notranslate">sprite</span> の<span class="notranslate">loop</span> を上下にスケールするようにします。まず、<span class="notranslate">object</span> を開いて（または作成して）、それに<span class="notranslate">sprite</span> を割り当て、<span class="notranslate">object</span> に<strong>Create Event</strong> を与えます。このイベントには、以下を追加します。</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">timer = 0;</p>
    <p class="dropspot">次に、<span class="notranslate">object</span> 、次のように<strong>Step Eventを</strong>追加します。</p>
    <p class="dropspot"><img alt="Example Showing Colour Blending" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_2.png" /></p>
    <p class="code">timer = timer + 1;
      <br />
      var _val = dsin(timer);
      <br />
      image_xscale = 1 + _val;
      <br />
      image_yscale = 1 + _val;
    </p>
    <p class="dropspot">ここでは、maths 関数を使用しています。 <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/dsin.htm"><span class="inline">dsin()</span></a>を使用して、タイマ変数を使用して -1 から 1 の間の値を生成し、それをスケール変数に適用しています。いくつかのインスタンスを<span class="notranslate">room</span> に配置し、<strong>再生 </strong>ボタン<img> を押すと、インスタンスがスケール 0 からスケール 2 へとスケールアップし、また元に戻る様子がわかるはずです。</p>
    <p class="dropspot"><img alt="GML VisualSet Variable Example" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_1.png" /></p>
    <p class="dropspot">最後にもう一つ... &quot; <span class="inline">image_yscale</span>&quot; の部分を &quot; <span class="inline">1 - _val</span>&quot; に変更して、どうなるか見てみてください。</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>上記の例は、<span data-keyref="GameMaker Name">GameMaker</span>がデフォルトで描画しているときに<span class="notranslate">object</span> <span class="notranslate">sprite</span> を操作できる多くの方法のほんの一部です。しかし、<span class="notranslate">object</span> に対して複数のものを描きたい場合はどうでしょうか。その場合は、<strong>Draw イベントを使って</strong>、何を描くかを<span data-keyref="GameMaker Name">GameMaker</span>に明示的に指示する必要があります。</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">2つ（またはそれ以上）の描画<span class="notranslate">Sprites</span> 一緒に描画する</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">この例では、2つの<span class="notranslate">sprites</span> と1つの<span class="notranslate">object</span> が必要です。<span class="notranslate">sprites</span> を &quot; <span class="inline">spr_One</span>&quot; と &quot; <span class="inline">spr_Two</span>&quot; と呼び、 &quot; <span class="inline">spr_One</span>&quot; の原点を中央に、 &quot; <span class="inline">spr_Two</span>&quot; の原点を左中段に設定します。</p>
    <p class="dropspot"><img>作成した<span class="notranslate">sprite</span> に最初の<span class="notranslate">object</span> (&quot; <span class="inline">spr_One</span>&quot; を中心原点とする) を割り当て、<strong>Create Event</strong>を追加します。Create Eventに、以下の<span class="notranslate">GML</span> VisualまたはGMLを追加します。</p>
    <p class="dropspot"><img alt="GML VisualActions To Change Sprite Scale" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_2.png" /></p>
    <p class="code">draw_angle = 0;</p>
    <p class="dropspot">この変数を使って、&quot; <span class="inline">spr_Two</span>&quot; を時間と共に回転させ、<span class="notranslate">sprite</span> に割り当てられた<span class="notranslate">object</span> (&quot; <span class="inline">spr_One</span>&quot;) の上に重ねて描画するつもりです。これを行うには、<span class="notranslate">object</span> に<strong>Draw Event </strong>を追加する必要がある。こうすることで、<span data-keyref="GameMaker Name">GameMaker</span>にインスタンスの描画を引き継ぎたいことを伝えることになる。 <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_self.htm"><span class="inline">draw_self()</span></a>関数または <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Draw_Self.htm"><strong>自己の描画</strong></a>アクションの呼び出しを含むことになる。このアクションは、Draw Event が存在しないときに<span class="notranslate">object</span> が行うことを再現するだけで、割り当てられた<span class="notranslate">sprite</span> をデフォルトで描画します。次に、回転しているオーバーレイ<span class="notranslate">sprite</span> として使用したい 2 番目の<span class="notranslate">sprite</span> を描画します。<span class="notranslate">GML</span> Visual と<span class="notranslate">GML</span> はこのようになります。</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = draw_angle + 0.5;
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot"><span class="notranslate">object</span> エディタに<span class="notranslate">room</span> のインスタンスをいくつか追加し、<a class="glossterm" data-glossterm="アイディーイー" href="#">IDE</a> の上部にある<strong>再生 </strong>ボタン<img> を押してください。すべてが正しく行われていれば、次のようなものが表示されるはずです。</p>
    <p class="dropspot"><img class="center" src="../assets/Images/QS_Guide/QS_DrawExample_3.gif" title="Animation Showing Sprite Scaling" /></p>
    <p class="dropspot">この例を終える前に、少し手を加えてみましょう。&quot; <span class="inline">spr_Two</span>&quot;を単に回転させるのではなく、マウスの位置の方に向けるようにします。そのためには、描画イベント<span class="notranslate">GML</span> Visual または<span class="notranslate">GML</span> を次のように変更する必要があります。</p>
    <p class="dropspot"><img alt="Show Origins For Sprites" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_1.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = point_direction(x, y, mouse_x, mouse_y);
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot">もう一度プロジェクトを実行すると、今度は全く違うものが見えてきますよ。</p>
    <p class="dropspot"><img> <span class="notranslate">sprite</span> は、あなたがどこに動かしても、マウスの方を指すようになりました!このように、 を重ねることは、 に詳細を追加したり、 に割り当てられた「ベース」 から独立して何かを動かすのに最適な方法で、おそらくあなた自身のプロジェクトでたくさん使用することになる強力なツールです。<span class="notranslate">sprites</span> <span class="notranslate">object</span> <span class="notranslate">sprite</span> <span class="notranslate">object</span> </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down4" href="#">スプライト以外のものを描く</a></p>
  <div class="droptext" data-targetname="drop_down4">
    <p class="dropspot">テキストや図形など、<span class="notranslate">sprites</span> 以外のものも Draw イベントで描画することができます。この例では、<span class="notranslate">GML</span> Visual または<span class="notranslate">GML</span> <span class="inline">draw_self()</span> 関数を使用して、<span class="notranslate">object</span> <span class="notranslate">sprite</span> を描画しますが、<strong>テキストを</strong>始めとして他のものも描画します。この例では、<span class="notranslate">sprite</span> と<span class="notranslate">object</span> (<span class="notranslate">sprite</span> が割り当てられている) が必要です。<span class="notranslate">object</span> で、まずこの<span class="notranslate">GML</span> Visual または GML を使った<strong>Create Event</strong>を追加します。</p>
    <p class="dropspot"><img alt="Set Draw Angle Variable In DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_1.png" /></p>
    <p class="code">name = choose(&quot;Fred&quot;, &quot;Jonas&quot;, &quot;Sharon&quot;, &quot;Kate&quot;, &quot;Frank&quot;, &quot;John&quot;, &quot;Monica&quot;, &quot;Amanda&quot;);
      <br />
      number = irandom(100);
    </p>
    <p class="dropspot">これは<span data-keyref="GameMaker Name">GameMakerに</span>、リストされた名前の中から1つを選んで変数に代入し、<span class="notranslate">object</span> のインスタンスごとに0から100までの乱数を生成するように指示するだけです。これらの値を画面に描画したいので、そのために<strong>Draw Eventを</strong>追加して、その中に次の<span class="notranslate">GML</span> VisualまたはGMLを追加します。</p>
    <p class="dropspot"><img alt="Draw Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_2.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">上記のコードで、以下のように <a href="../GameMaker_Language/GML_Reference/Strings/string.htm"><span class="inline">string()</span></a>関数または <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Data_Types/Number_To_String.htm"><strong>数値から文字列へ</strong></a>アクションを使っていることに気づくだろう。これは、すべてのテキストは値ではなく<em>文字で</em>構成されなければならないため、この関数やアクションを使って、数値の値を描画したい文字に変換する必要があるためです。この例では、生成した乱数を、描画可能な文字の「文字列」に変換しています。また、<strong>テキストアライメントを</strong>設定していることにも注目してください。これは<span data-keyref="GameMaker Name">GameMakerに</span>、与えられた位置から相対的にどの位置からテキストを描き始めるかを指示するもので、今回はテキストをX軸の中央に配置することにします。</p>
    <p class="dropspot"><span class="notranslate">object</span> のインスタンスを<span class="notranslate">room</span> エディタにいくつも追加し、<span class="notranslate">IDE</span> の上部にある再生ボタン<img> を押してください。 このようなものが表示されるはずです。</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">今までの例では、インスタンスに割り当てられた<span class="notranslate">sprite</span> を描画していましたが、必ずしもそうである必要はありません。draw イベントでは、割り当てられた<span class="notranslate">sprite</span> に関係なく、<strong>好きなものを描画</strong>することができます。この点を説明するために、現在あるコードを変更して、 <span class="inline">draw_self()</span> の呼び出しを削除し、次のように色のついた楕円を描画する関数に置き換えることにします。</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_2.gif" /></p>
    <p class="code">draw_ellipse_colour(x - 50, y - 32, x + 50, y + 32, c_fuchsia, c_lime, false);
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">プロジェクトを再度実行すると、このように表示されるはずです。</p>
    <p class="dropspot"><img alt="Edited Draw Code For Drawing Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_3.png" /></p>
    <p class="dropspot">これに関して重要なことは、割り当てられた<span class="notranslate">sprite</span> を描画していなくても、<strong>衝突検出のために使用</strong>されることです。つまり、あるものを描画していても、衝突は割り当てられた<span class="notranslate">sprite</span> に基づいて計算され、それが表示されていなくても、インスタンスと一緒に<span class="notranslate">room</span> に配置されているかのように計算されます。これは非常に便利で、異なる<span class="notranslate">sprites</span> を描画しても、割り当てられた<span class="notranslate">sprite</span> に基づいて 1 つの<strong>コリジョンマスクを</strong>維持することができることを意味します。また、X/Y スケールのような異なるトランスフォームを適用することができ、衝突は変更されたサイズに基づきますが、これを示すために何も描画されていないことに注意してください。</p>
  </div>
  <p> </p>
  <p> </p>
  <h1>GUIレイヤー</h1>
  <p>このページの一番上に、<strong>Draw イベントだけでなく、Draw GUI イベントについても</strong>説明すると書きましたので、今度はそれについて見てみましょう。<strong> <a class="glossterm" data-glossterm="GUI" href="#">GUI</a></strong> <strong> <a class="glossterm" data-glossterm="GUI" href="#"></a></strong>レイヤーは固定された幅と高さの特別な描画レイヤーで、<span class="notranslate">room</span> のインスタンスの上に描かれます。GUIレイヤーの素晴らしい点は、<em> <span class="notranslate">room</span> </em> カメラと一緒に動かないので、スコアやヘルスバーなど、ゲームがユーザーに伝える必要がある情報を静的なGUIアイテムとして追加するのに理想的な場所である点です。GUIレイヤーの詳細については、マニュアルの「<a href="../The_Asset_Editors/Object_Properties/Draw_Events.htm">描画イベント</a>」のセクションを参照してください。</p>
  <p class="note"><strong>注意</strong>：<span class="notranslate">Rooms</span> はスクリーンサイズより大きくすることができるので、プレイヤーが動き回るための大きなレベルを持つことができます。つまり、<span class="notranslate">Room</span> エディタで（またはコードで）、ゲームのアクションに追従する<strong>カメラを </strong>定義する必要があるのです。これは基本的に、画面の固定エリアを設定して、例えば<span class="notranslate">room</span> におけるプレイヤーの位置に基づいて、より大きな<span class="notranslate">room</span> の異なる部分を表示する方法であり、多くのゲームで使用されています。マリオやゼルダのような古典的なゲームでは、常に主人公の後を追うように表示されることを思い浮かべてください。これはカメラで行われています。詳しくは、マニュアルの<span class="notranslate">Room</span> Editor の<a href="../The_Asset_Editors/Room_Properties/Room_Properties.htm">Room Properties</a>の項を参照してください。</p>
  <p>以下の例では、すべて<strong>Draw GUI</strong>イベントを使用します。したがって、<span class="notranslate">object</span> を作成し、そのイベントを追加する必要があります。<span class="notranslate">object</span> は<span class="notranslate">sprite</span> を割り当てる必要がないことに注意してください。デフォルトで何かを描画したり、衝突を検出したりする必要はありません。このように、描画やゲームの特定の側面を制御するためだけに設計された<span class="notranslate">Objects</span> は、しばしば<strong>Controller Objects</strong> と呼ばれます。また、すべての例で同じ<span class="notranslate">object</span> を使うので、順番に見ていくことをおすすめします（ただし、厳密には必要ではありません）。</p>
  <p><img> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down5" href="#">描画テキスト</a></p>
  <div class="droptext" data-targetname="drop_down5">
    <p class="dropspot">GUIレイヤーに描画する場合、左上を原点位置とし、右側が+X、下側が+Yとなります。この例でわかるように、テキストやグラフィックの位置決めが非常に簡単になります。ここでは、プレイヤーのスコアを表す値を描画するだけなので、<span class="notranslate">object</span> で、この値を保持する変数を初期化するために、次のように<strong>Create Event </strong>を追加する必要があります。</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Pointing At Mouse" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_3.gif" /></p>
    <p class="code">player_score = 0;</p>
    <p class="dropspot">また、Spaceキーを押すたびにスコアを増加させるために、<strong>Keyboard Down &lt;Space&gt; Eventを</strong> <span class="notranslate">object</span> に追加します。</p>
    <p class="dropspot"><img alt="Setting Variables Using DnD" class="center" height="506" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1_1.png" width="317" /></p>
    <p class="dropspot">このイベントでは、以下を追加します。</p>
    <p class="dropspot"><img alt="Drawing Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1.png" /></p>
    <p class="code">var _val = irandom(100);
      <br />
      player_score = player_score + _val;
    </p>
    <p class="dropspot">最後に、Draw GUI イベントでスコア値をこのように描画してみましょう。</p>
    <p class="dropspot">このイベントでは、以下を追加します。</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_set_halign(fa_left);
      <br />
      draw_set_colour(c_yellow);
      <br />
      draw_text(32, 32, &quot;SCORE:&quot;);
      <br />
      draw_set_colour(c_white);
      <br />
      var _str = string(player_score);
      <br />
      draw_text_transformed(32, 48, _str, 2, 2, 0);
    </p>
    <p class="dropspot">GUIレイヤーに描画するため、どのインスタンスに対しても相対的である必要はないので、描画するテキストのx/y位置に<a class="glossterm" data-glossterm="ハードコード化" href="#">ハードコード</a>（または固定）値を使用していることにお気づきでしょう。また、「set color」関数でテキストの色を変更し、「transformed」関数で実際のスコア値を大きくしています。これは、自分のゲームでテキスト要素をカスタマイズする方法を示すものです。</p>
    <p class="dropspot">この<span class="notranslate">object</span> のインスタンスを<span class="notranslate">room</span> に追加し、<strong>再生 </strong>ボタン<img> を押してください。ゲームが実行されたら、 <span class="inline">&lt;Space&gt;</span> キーを押して放すと、スコアの値が増加するのがわかるはずです。</p>
    <p class="dropspot"><img alt="Sprites Being Drawn Along With Text" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down6" href="#">スプライトの描画</a></p>
  <div class="droptext" data-targetname="drop_down6">
    <p class="dropspot">この例では、GUIレイヤーを使って、<span class="notranslate">sprites</span> を描画します。この最も明白な用途は、プレイヤーの生活を描くことです。この例では、<span class="notranslate">sprite</span> が必要です。大きさは約64x64ピクセルで、<span class="notranslate">object</span> に割り当てる必要はなく、私たち自身で描画します。</p>
    <p class="dropspot">まず始めに、<strong>Create Event</strong>の<span class="notranslate">object</span> に新しい変数をいくつか追加する必要があります（前の例を行った場合は、既にあるものの下に以下を追加してください）。</p>
    <p class="dropspot"><img alt="Drawing Shapes Along With Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_2.png" /></p>
    <p class="code">player_lives = 3;
      <br />
      gui_w = display_get_gui_width();
    </p>
    <p class="dropspot">このコードでは、プレイヤーライフ用の変数を初期化していますが、GUIレイヤーの幅を保持する変数も作成し、画面の右側に対して正しく配置できるようにしています。値をハードコードして使うこともできますが、その場合、<span class="notranslate">room</span> のサイズを変更したり、カメラを追加したりすると、コードを調べて値を変更する必要があります。代わりに <a href="../GameMaker_Language/GML_Reference/Cameras_And_Display/display_get_gui_width.htm"><span class="inline">display_get_gui_width()</span></a>関数を使うことで、GUIレイヤーがどのようなサイズになろうと、コードが自動的に適応するため、将来の変更について心配する必要がありません。</p>
    <p class="dropspot">次に、<strong>キーボードが押された &lt;Enter&gt; イベントを</strong> <span class="notranslate">object</span> に追加します。これは、Enter キーが押されるたびにライフの数を変更するために使用します。</p>
    <p class="dropspot"><img alt="Example Of Drawing Shapes And Text Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_2.png" /></p>
    <p class="dropspot">このイベントでは、以下を追加します。</p>
    <p class="dropspot"><img alt="Draw GUI Event In An Object" class="center" src="../assets/Images/QS_Guide/QS_DrawGUIObject.png" /></p>
    <p class="code">player_lives = player_lives - 1;
      <br />
      <br />
      if player_lives &lt; 0
      <br />
      {
      <br />
      player_lives = 3;
      <br />
      }
    </p>
    <p class="dropspot">最後に、<span class="notranslate">sprites</span> をディスプレイに描画する必要があります。これには、&quot; <span class="inline">for</span>&quot;<span class="notranslate">loop</span> (<span class="notranslate">GML</span> を使った情報は<a href="../GameMaker_Language/GML_Overview/Language_Features/for.htm">こちら</a>、<span class="notranslate">GML</span> Visual は<a href="../Drag_And_Drop/Drag_And_Drop_Reference/Loops/For.htm">こちら</a>)を使い、GUI width 変数ですべてを画面の右上隅に配置することになります。そこで、これをDraw Gui Eventに追加します（以前の例から持っている可能性のある他のアクションの後に）。</p>
    <p class="dropspot"><img alt="Defining A Variable Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_1.png" /></p>
    <p class="code">for (var i = 0; i &lt; player_lives; i += 1)
      <br />
      {
      <br />
      var _xx = gui_w - 48 - (i * 70);
      <br />
      draw_sprite(spr_Heart, 0, _xx, 48);
      <br />
      }
    </p>
    <p class="dropspot">この<span class="notranslate">object</span> のインスタンスをまだ<span class="notranslate">room</span> に追加していない場合は、今すぐ追加してください（1つだけです！）、そして<strong>再生 </strong>ボタン<img> を押してください。ゲームが起動したら、 <span class="inline">&lt;Enter&gt;</span> キーを何度も押して、ライフが変化するのを確認します。</p>
    <p class="dropspot"><img alt="Adding A Space Key Pressed Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="dropspot">この例から離れる前に、ライフの数を実験してどうなるかを見てみましょう。今は3になっていますが、CreateイベントとKey Pressedイベントを変更して、5や10にしてみてください。</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down7" href="#">ヘルスバーを描く</a></p>
  <div class="droptext" data-targetname="drop_down7">
    <p class="dropspot">この最後の例は、GUIレイヤーにヘルスバーを描画するものです。これにはいくつかの方法がありますが、<span data-keyref="GameMaker Name">GameMakerには</span>ヘルスバーを描くための特別な機能が組み込まれているので、ここではそれを使います。ただし、<span class="notranslate">sprites</span> やシェイプを使って自分で作成することも可能です。まず、先ほどと同じように、ヘルスバーの値を保持するための変数（varaible）を初期化する必要があります。そこで、<span class="notranslate">GML</span> の<strong>作成</strong>イベントに、次の<span class="notranslate">GML</span> Visual または<span class="notranslate">object</span> を追加します（すでに存在する他のコードの後に）。</p>
    <p class="dropspot"><img alt="GML VisualActions In The Space Key Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_2.png" /></p>
    <p class="code">player_health = 100;</p>
    <p class="dropspot">どの矢印キーが押されたかに応じて健康値を上下に変更するために矢印キーを使用したいので、2つの<strong>Keyboard Pressed &lt;Arrow&gt;</strong>イベントを追加することでそれを行うことができます。しかし、おそらく<strong>ステップイベントと</strong>キーをチェックするいくつかのコードを使用する方が簡単なので、次の<span class="notranslate">GML</span> VisualまたはGMLで<strong>ステップ</strong>イベントを追加しましょう。</p>
    <p class="dropspot"><img alt="Drawing Text To The GUI Layer Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_3.png" /></p>
    <p class="code">if keyboard_check(vk_up)<br />
      {<br />
          if player_health &lt; 100<br />
          {<br />
              player_health = player_health + 1;<br />
          }<br />
      }<br />
      <br />
      if keyboard_check(vk_down)<br />
      {<br />
          if player_health &gt; 0<br />
          {<br />
              player_health = player_health - 1;<br />
          }<br />
      }
    </p>
    <p class="dropspot">これで、ヘルスバーの描画ができるようになりました。これは、Draw GUI イベントで、次のように追加します（すでにあるものの後に）。</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _xx = display_get_gui_width() / 2;<br />
      <br />
      draw_healthbar(_xx - 50, 24, _xx + 50, 40, player_health, c_black, c_red, c_lime, 0, true, true);
    </p>
    <p class="dropspot"><img>この<span class="notranslate">object</span> のインスタンスを<span class="notranslate">room</span> にまだ追加していないなら、追加してください（ただし、1つだけです！）<strong>。 </strong>ゲームが起動したら、 <span class="inline">&lt;Up Arrow&gt;</span> と <span class="inline">&lt;Down Arrow&gt;</span> のキーをいろいろと押して、健康状態が変化するのを確認します。</p>
    <p class="dropspot"><img alt="Animation Showing Text Being Drawn To The GUI Layer" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_6.gif" /></p>
  </div>
  <p> </p>
  <p>これらの例を見て、<span data-keyref="GameMaker Name">GameMaker</span>を使うのに少し自信がつき、どのように動くのかが少し理解できたと思います。次の章では、今まで描いてきたものを、<span class="notranslate">room</span> の中で動かし、ユーザーの入力を受け入れ、それに反応させる方法を探っていきます。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">戻る：<a href="../Content.htm">インデックス</a></div>
        <div style="float:right">次へ<a href="Movement_And_Controls.htm">動作と制御</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Drawing
Drawing Examples
Quick Start Drawing
-->
  <!-- TAGS
qs_drawing
-->
</body>
</html>