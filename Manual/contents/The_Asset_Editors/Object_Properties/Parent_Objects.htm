<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>親オブジェクト</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing object parenting" />
  <meta name="rh-index-keywords" content="Objects - Parents" />
  <meta name="search-keywords" content="parent,child,inheritance,object parenting" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
  <script src="../../assets/scripts/main_script.js"></script>
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>親オブジェクト</h1>
  <p><span data-keyref="GameMaker Name">GameMaker</span>で<span class="notranslate">objects</span> を扱う場合、<span class="notranslate">IDE</span> 、<strong>親/ </strong>子の階層を設定することができます。これは、<span class="notranslate">object</span> エディターで「親」ボタンをクリックし、<span class="notranslate">object</span> ブラウザーから別の<span class="notranslate">Asset</span> を選択することで行われます。
    を編集中のものの「親」にします。</p>
  <p><img>つまり、ゲームプロジェクト内のすべての<span class="notranslate">object</span> は、親<span class="notranslate">object</span> を持つことができますが、これはどういう意味でしょうか。<span class="notranslate">object</span> に親が割り当てられると、次のことが可能になります。
    は、その親とコード、アクション、イベントを共有します。この共有は「継承」と呼ばれ、親を持つ<span class="notranslate">object</span> は「子」<span class="notranslate">object</span> と呼ばれます。子は親とコードを共有できるだけでなく、チェックやコードの実行も可能です。
    を親<span class="notranslate">objects</span> の上に置くと、自動的に子<span class="notranslate">objects</span> も含まれるため、時間と労力が大幅に節約されます。</p>
  <p>もし、それが複雑に聞こえるなら、親<span class="notranslate">object</span> の別の見方は、同じ傘の下で<span class="notranslate">objects</span> を「グループ化」し、独自のアイデンティティを失うことなく特定のものを共有させる方法である。それでもまだ
    というわけで、いくつか例を挙げてみましょう。</p>
  <p>例えば、「プレイヤー」<span class="notranslate">object</span> と4種類の「敵」<span class="notranslate">objects</span> があるとします。さて、プレイヤーがこれら4つの<span class="notranslate">objects</span> のどれかに触れると死ぬようにしたいとします。通常、これには4つの異なる衝突イベントと4つの異なるセットの
    アクションまたはコード、敵のそれぞれについて1つずつ<span class="notranslate">objects</span>.しかし、すべての敵に親<span class="notranslate">object</span> を作ると、親<span class="notranslate">object</span> との衝突イベントを1つだけ作ることができ、4つの「子」敵のどれに関係なくトリガーされるようになります。
    <span class="notranslate">objects</span> がプレイヤーに触れる。便利なものですね。実際の<span data-keyref="GameMaker Name">GameMaker</span> <span class="notranslate">object</span> では、このような感じになっています。</p>
  <p><img>左側には4つの衝突イベントがあり、右側には1つの衝突イベントがあります。
    &quot;親&quot;<span class="notranslate">object</span> に、すべての敵<span class="notranslate">objects</span> を割り当てました。親<span class="notranslate">object</span> は、イベントやコードを持つ必要がないことに注意してください...</p>
  <p>ペアレンティングの他の例としては、10種類の異なる外見の<span class="notranslate">objects</span> を作成し、すべて同じように動作させたい場合などがあります。この場合、親となる<span class="notranslate">object</span> を1つ作成し、その中にすべての動作やコードを記述します。
    そして、アクションやコードがなく、異なる<span class="notranslate">objects</span> を持つ 10 個の<span class="notranslate">sprites</span> を作成し、それらを親<span class="notranslate">object</span> に割り当てます。これで、これらのインスタンスを<span class="notranslate">room</span> に配置すると、動作はすべて同じになりますが、見た目は違ってきます。
    なぜなら、それらは親のイベントを「継承」するからです。</p>
  <p>最後に、ペアレンティングを使って、イベントとビヘイビアを「ミックス＆マッチ」させることができます。最後の例で説明しましょう。例えば、上下に動くモンスターと、左右に動くモンスターの2匹を用意したとします。
    2匹の体力は同じで、プレイヤーに向かって銃を撃ち、ぶつかるとプレイヤーにダメージを与える。この場合、移動を司る1つか2つのイベントを除いて、ほとんどすべてのイベントが同じアクションを持つべきことがわかります。そこで、もう一度
    1つの<span class="notranslate">object</span> がもう1つの親になりますが、この場合、子である<span class="notranslate">object</span> にもある種のイベントを定義します。これらのイベントは親イベントを「オーバーライド」します。つまり、子<span class="notranslate">object</span> のイベントにアクションが含まれている場合は常に、これらのイベントが実行されます。
    の代わりに、親のイベントに含まれるアクションを実行します。親のイベントも実行したい場合は、いわゆる「継承」イベントを関数 <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a>,
    または<span class="notranslate">GML</span> Visual アクション<a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">Call Parent Event</a> を使用します。</p>
  <p><img>上の左側が5つのイベントを持つ親<span class="notranslate">object</span> で、右側には「子」<span class="notranslate">object</span> が見えます。子オブジェクト
    も5つのイベントを持ちますが、そのうち2つは親から継承したイベント（<strong>Stepと </strong> <strong>Draw </strong>イベント）をオーバーライドし、残りの3つは親から継承したイベントのためグレーアウトされています。継承されたイベント
    には、イベントエディターの横に「parent override（親を上書き）」アイコンが表示されます。</p>
  <p><img>継承されたイベントをクリックすると、<img> 。
    をクリックすると、コードエディターが開き、継承された親コードが表示されます。ただし、このコードは親である<span class="notranslate">object</span> 自身でしか編集できないため、編集することはできません。親イベントの上でマウスの右ボタン<img> をクリックすると、次のようなオプションメニューが表示されます。</p>
  <p><img>ここでは、<strong>親イベントを開いて </strong>コードを確認する方法と、親イベントを<strong>継承 </strong>する方法を選択することができます。
    イベントを<strong>オーバーライド </strong>します。<strong>継承を </strong>選択した場合、コードエディターが開き、関数 <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a>すでに
    に追加されます (<span class="notranslate">GML</span> Visual を使用している場合は、<a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">親イベントの呼び出し</a>アクション)。このイベントに追加したコードは、親オブジェクトのコードと同じように実行されます。
    が持っています。イベントを<strong>上書き </strong>する」を選択すると、コードウィンドウも開きますが、 <span class="inline">event_inherited()</span> 関数は呼び出されないので、ここに追加したコードはすべて次のコードの<em>代わりに </em>実行されます。
    を親に持つ<span class="notranslate">object</span> 。</p>
  <p class="note"><strong>注</strong>：コードエディタから、マウスの右ボタン<img> をクリックし、ポップアップメニューから「<strong>Go To Object</strong>」を選択すると、素早く親の<span class="notranslate">object</span> に移動できます。また、（イベントがオーバーライドされている場合）「<strong>Open Inherited Event</strong>」を選択して、親イベントコードが入ったコードエディタに直接移動することも可能です。</p>
  <p>コードで親<span class="notranslate">object</span> をターゲットにした場合、そのコードは親<span class="notranslate">object</span> の「子」にも適用されます。これは、アクションで、アクションが特定の<span class="notranslate">object</span> のインスタンスに適用される必要があることを示すときに起こります。
    を使用したときに発生します。 <a href="../../GameMaker_Language/GML_Overview/Language_Features/with.htm"><span class="inline">with()</span></a>ステートメントを使用します。のようなコード関数を呼び出すときにも、このように動作します。 <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_position.htm"><span class="inline">instance_position()</span></a>,
    <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_number.htm"><span class="inline">instance_number()</span></a>親を指定した場合、<span class="notranslate">object</span> -<em>親と </em>子のすべてのインスタンスが表示されます。
    がチェックに含まれます。最後に、ペアリングは他の<span class="notranslate">objects</span> の変数を参照するときにも働きます。例えば、上のモンスターの例で、敵1のスピードを10に設定すると、敵2のスピードも10になり、敵の子である<span class="notranslate">object</span> 
    1.</p>
  <p>一般に、ほとんどの場合、1つの基本親<span class="notranslate">object</span> を作成し、この基本<span class="notranslate">object</span> にすべてのデフォルトの動作を含ませますが、ゲーム内でそのインスタンスを使用しないことが良い習慣とされています。むしろ、すべての子<span class="notranslate">objects</span> を使用し、親を使用するのは
    上記で説明したような状況、衝突、変数の参照などです。また、親は親を持つことができることも知っておく必要があります。もちろん、「親1は親2の子であり、親2は親2の子である」というサイクルは作れません。
    しかし、「<em>parent3は </em> <em>parent2の </em>子であり、<em>parent1の</em>子である」という、いわゆる「オブジェクト階層」を作ることは可能です。これはゲームの構造を維持するために非常に有効であり、強くお勧めします。
    この仕組みを使いこなすことです。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">戻る<a href="../Objects.htm"> <span class="notranslate">Object</span> 編集部</a></div>
        <div style="float:right">次へ<a href="Physics_Objects.htm">物理オブジェクト</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2021 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Parent Objects
Child Objects
parent
child
inheritance
-->
  <!-- TAGS
parent_objects
-->
</body>
</html>