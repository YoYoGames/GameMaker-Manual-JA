<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>ルームプロパティ</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the different room properties" />
  <meta name="rh-index-keywords" content="Rooms - Room Settings" />
  <meta name="search-keywords" content="room settings,cameras,viewports,room size,room properties,view cameras" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>ルームプロパティ</h1>
  <p><img> <span class="notranslate">Room</span> プロパティセクションでは、設定の継承トグルの設定、パーシステント、ルームのサイズなどのオプションの変更、ビューポートの管理などができます。</p>
  <h2>持続性</h2>
  <p>通常、<span class="notranslate">room</span> を出て、後で同じ<span class="notranslate">room</span> に戻ると、その<span class="notranslate">room</span> は初期設定にリセットされます。これはほとんどのゲームでは問題ありませんが、例えばRPGやノンリニアゲームで、<span class="notranslate">rooms</span> の間を行き来して、最後に出た時の状態にしたい場合、そうならないかもしれません。<strong>Persistent(永続的 </strong>)というラベルのついたボックスをチェックすると、まさにそれが可能になります。<span class="notranslate">room</span> の状態は記憶され、後で戻ってきたときにも、あなたが去ったときとまったく同じ状態になっており、ゲームを再起動したときだけ、スタート時の状態にリセットされます。ある<span class="notranslate">objects</span> を永続化するようにマークした場合、その<span class="notranslate">object</span> のインスタンスは<span class="notranslate">room</span> に<em>とどまらず </em>、次の<span class="notranslate">room</span> に移動することに注意しましょう。</p>
  <h2 id="clear_display_buffer">ディスプレイバッファのクリア</h2>
  <p>その後、「<strong>ディスプレイバッファをクリア</strong>する」というオプションがあります。このオプションをチェックすると、特定のフレームで何かを描画する前に、<a class="glossterm" data-glossterm="ディスプレイバッファ" href="#">ディスプレイバッファを</a>あらかじめ色で満たします。ビューが常に画面全体を覆っている場合や、フルスクリーンで不透明な背景が描かれている場合は、このオプションをオフにすると、再描画が節約され、ゲームの最適化に役立ちます。</p>
  <p>ただし、複数のビューを表示しているときに画面上に空き領域があったり、背景が透明な部分があったりする場合は、これをチェックすると、空き領域が任意の描画色で塗りつぶされるようになります。現在のところ、この色は <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/The_Game_Window/window_set_colour.htm"><span class="inline">window_set_colour()</span></a>.</p>
  <p class="note"><span class="note">注</span>：自動アスペクト比補正（<a href="../../Settings/Game_Options.htm">ゲームオプション</a>で設定）を使用している場合は、<strong>常に </strong>このオプションをチェックする必要があります。そうしないと、ゲームが描画される「レターボックス」に奇妙な効果が発生する可能性があります。このオプションを使用しない場合は、このチェックを外すと、ゲームのパフォーマンスが少し向上します（特に、<span class="notranslate">Android</span> やその他のモバイルプラットフォームで顕著になります）。</p>
  <h2>幅、高さ、その他オプション</h2>
  <p><span class="notranslate">room</span> にはサイズが必要で、これは幅と高さをピクセル単位で入力した値で定義されます。</p>
  <p>その後、必要であれば、<strong>作成コードを</strong>追加することができます。作成コードは、下部にあるボタン（<span class="notranslate">inherit</span> トグルと一緒に、<span class="notranslate">room</span> が作成コードを<span class="notranslate">inherit</span> するかどうかを指定します）から追加します。これをクリックすると、コードエディタまたはビジュアルエディタが開きます。このエディターでは、<span class="notranslate">room</span> の<em>開始 </em>時に実行される関数/アクションやコードを入力できます。すべてのインスタンスの create イベントの後、<span class="notranslate">room</span> の開始イベントの前に実行されます（イベントの順序に関する詳細は、<a href="../Object_Properties/Event_Order.htm">こちらを</a>参照してください）。このコードは、<span class="notranslate">room</span> に入るたびに実行されます。ただし、<span class="notranslate">room</span> が永続的であると判定された場合は、<span class="notranslate">room</span> に最初に入ったときに一度だけ実行され、その後<span class="notranslate">room</span> にアクセスしたときには実行されません。</p>
  <h2 id="creation_order">インスタンス作成順</h2>
  <p><span class="notranslate">Room</span> Properties の最後のボタンは、<strong>Instance Creation Order</strong>ウィンドウを開くことを許可します。</p>
  <p><img>このウィンドウには、<span class="notranslate">room</span> のすべてのインスタンスが、作成される順番に（上から下へ）リストアップされています。特定のインスタンスを他のインスタンスより先に作成したい場合は、<img> をクリックし、必要な位置までドラッグするだけでよいのです。インスタンスはリストの上から下の順に作成されることに注意してください。</p>
  <div data-conref="../../assets/snippets/Instance_creation_order_warning.hts"> </div>
  <p> </p>
  <p> </p>
  <h1>カメラとビューポート</h1>
  <p>次に定義できる<span class="notranslate">room</span> のプロパティは、部屋の<strong>カメラと</strong> <strong>ビューポートに</strong>関連するものです。カメラビューは、<span class="notranslate">room</span> の異なる部分を画面上の異なる場所に描いたり、<span class="notranslate">room</span> の一部だけを描いて画面全体をカバーしたりするための仕組みを提供します。たとえば、ほとんどのプラットフォームゲームでは、カメラビューはメインキャラクターを追います。画面上でレベル全体を見ることができたら、キャラクターが小さすぎて見えなくなり、プレイヤーに驚きを与えることができないからです。カメラビューは、マルチプレーヤーゲームや協力型ゲームでも使用でき、画面の一部で一方のプレーヤーが見え、別の一部でもう一方のプレーヤーが見えるという画面分割が可能になります。<span data-keyref="GameMaker Name">GameMakerでは</span>、カメラビューを使うことで、このようなことが簡単に実現できます。</p>
  <p><img>ビューのプロパティの上部に、ビューの継承のオンオフを切り替えることができ、次に、<strong>ビューポートを有効に</strong>するというラベルのついたボックスがあります。これは、カメラビューをゲームで使用する前に<em>フラグを立てる必要が</em>あります。</p>
  <p class="note"><span class="note">注</span>：3つのメインビューポート設定に対して継承のオン/オフを切り替え、その後、個々のカメラビューに対して継承のオン/オフを切り替えることができます。</p>
  <p>次のチェックボックスは、「<strong>ビューポートの背景をクリア</strong>」と書かれているもので、上記の「<a href="#clear_display_buffer">ディスプレイバッファをクリア</a>」と似ていますが、ビューポート専用のオプションです。有効にすると、各フレームを描画する前にウィンドウの色で<a class="glossterm" data-glossterm="アプリケーションサーフェス" href="#">アプリケーションサーフェイスを</a>クリアします。これにより、以前のフレームの内容など、背景の透明な部分から意図しないグラフィックが見えないようにします。したがって、背景に透明な部分がある場合は、このオプションを有効にすることが重要です (「<strong>ビューポートを有効にする</strong>」とともに)。</p>
  <p>カメラビューは、カメラビューそのものと、このビューが描画される画面上のポートという、2つの異なる値のセットで定義されます。これは時に混乱を招くことがあるので、それぞれの定義方法を説明する前に少し説明しましょう。</p>
  <ul class="colour">
    <li><strong>カメラ</strong>。<span class="notranslate">room</span> が画面上にどのように表示されるかを設定するために使用される<span class="notranslate">room</span> 内の点 (これは<span class="notranslate">room</span> エディタ内の抽象的な点で、その位置はビューとビューポートの設定に基づいて自動的に設定されます)。</li>
    <li><strong>見えるもの</strong>カメラの位置、投影、回転に基づき、カメラが見ているもの</li>
    <li><strong>ビューポート</strong>：物理的な画面の中で、カメラビューを表示する領域</li>
  </ul>
  <p><img>例えば、640x480 のカメラビューを<span class="notranslate">room</span> に表示し、ポートを 320x240 に設定すると、そのサイズのポートに縮小されたビューがスクリーンに表示されます。このように、画面（ポート）サイズを維持しながら、カメラビューを変更し、画面の同じ領域に<span class="notranslate">room</span> を多く、または少なく表示することができます。</p>
  <p>カメラビューは常に<span class="notranslate">room</span> に矩形の領域として定義され、この領域の左上隅の位置、幅、高さを指定します。次に、ビューポートを定義して、この領域が画面上のウィンドウのどこに表示されるかを指定する必要があります。ここでも左上隅の位置とサイズを指定します（左上隅が 0,0 以外だと、おかしな結果になることがあるので注意してください）。ポートは複数持つことができ、重なり合うことも可能です。その場合は、表示された順序で1つずつ描画されます。</p>
  <p>画面全体は<em>常に長方形の領域として定義されて</em>いるので、ポートがオフセットされていても長方形を形成し、空いたスペースは<a class="glossterm" data-glossterm="ディスプレイバッファ" href="#">ディスプレイバッファの</a>ウィンドウ色で埋められます。つまり、こうした状況では常に「<strong>ディスプレイバッファをクリア</strong>」をチェックしておかないと、ポート間のスペースに奇妙なアーティファクトが描かれることになります。下の画像では、2つのオフセットビューポートが見えますが、それらは正方形のウィンドウを作り、その「下」にはディスプレイバッファに描画される線があります。</p>
  <p><img>カメラには、<strong>オブジェクトフォロイングオプションも </strong>あります。これは、特定の<span class="notranslate">object</span> にカメラを「追従」させる（つまり、ビューのフォーカスを維持する）場合 に使用します。これを行うには、メニューアイコンの<img> をクリックし、ポップアップするリストから<span class="notranslate">object</span> を選択します（この<span class="notranslate">object</span> が<span class="notranslate">room</span> 内に複数ある場合は、そのうちの 1 つだけがカメラによって追従されます）。</p>
  <p>カメラの通常の動作は、追跡中のインスタンスがビューのエッジの周りに目に見えない境界を作る &quot;バッファ&quot; ゾーンに近づきすぎたときにのみ移動します。このゾーンは、<strong>Horizontal Border </strong>および<strong>Vertical Border </strong>の値を使用して定義することができ、たとえば、これらの値を 64 に設定すると、ビューの端から 64 ピクセルに達するまでビューは移動を開始せず、キャラクターを追従しないことを意味します。</p>
  <p>最後に、キャラクターが<span class="notranslate">buffer</span> ゾーンに到達したときにカメラが移動する<strong>水平</strong>および<strong>垂直 </strong>速度を指定できます。このデフォルト値は -1 です。このデフォルト値は基本的に &quot;瞬間的&quot; で、フォローインスタンスが水平境界または垂直境界<span class="notranslate">buffer</span> ゾーンの外に出た瞬間、ビューはその現在の位置にスキップされることを意味します。さて、これは常に望むものではないので、値を-1以外のものに設定することで、カメラの垂直および水平スクロール速度を設定することができます。0の値はビューを全く動かさないことを意味し、その他の正の値は任意のフレームで何ピクセル移動するかを意味します。したがって、水平速度を5に設定すると、ビューは水平方向にフレームあたり5ピクセルで<span class="notranslate">object</span> に追従します。</p>
  <p> </p>
  <p> </p>
  <h1>ルームフィジックス</h1>
  <p>ビルトインされた物理関数をゲームで使う前に、<span data-keyref="GameMaker Name">GameMaker</span>に<span class="notranslate">room</span> が物理<span class="notranslate">room</span> であることを伝える必要があります。これを行うには、<em>Room Physics</em>セクションの一番上にある<strong>Enable Physics </strong>というオプションにチェックを入れる必要があります (<span class="notranslate">room</span> の他の設定とは別に、このセクションの継承を切り替えることも可能です)。これは、<span class="notranslate">room</span> で物理インスタンスを動作させる前に、あらかじめ定義しておく必要がある基本的なプロパティです。世界をより正確に制御するには、コードを使用することができます（詳細は<a href="../../GameMaker_Language/GML_Reference/Physics/Physics.htm">物理関数を</a>参照してください）。</p>
  <p><img>次に行うべきことは、世界の<strong>重力の </strong>設定です。重力の強さと方向は、(0, 0)点を中心に設定したx/y位置の<a class="glossterm" data-glossterm="ベクトル" href="#">ベクトルで</a>計算されます。つまり、xが0、yが1であれば、重力の方向は<em>下向きで </em>、毎秒1メートルの力があります（より詳しい説明は、「<a href="../../GameMaker_Language/GML_Reference/Physics/The_Physics_World/The_Physics_World.htm">物理の世界</a>」を参照してください）。</p>
  <p>最後に、<span data-keyref="GameMaker Name">GameMaker</span>がすべての物理計算のベースとして使用する<strong> Pixels To Meters</strong>の比率を設定する必要があります。物理関数は実世界の計測値で動作するため、この値を設定する必要があります。使用している<span class="notranslate">objects</span> の平均ピクセルサイズが、適切なサイズのシミュレーション物理<span class="notranslate">objects</span> にほぼ変換されるまで、この設定を調整するとよいでしょう。</p>
  <p><span class="notranslate">room</span> で物理を有効にするということは、部屋の中のすべてのインスタンスが<em>物理関数と変数を使用して移動する必要が</em>あることに注意する必要があります。基本的に、インスタンスの X/Y 位置を設定したり、速度と方向を設定できる「従来の」移動と、移動に物理的な力と衝撃を必要とする「物理」移動があります。これらのシステムは<strong>相互に排他的</strong>で、物理以外の関数を使って物理インスタンスを動かすことはできませんし、物理関数を使って非物理インスタンスを動かすこともできません。</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">戻る<a href="../Rooms.htm"> <span class="notranslate">Room</span> 編集部</a></div>
        <div style="float:right">次へ<a href="Room_Inheritance.htm">部屋の相続</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright<span class="notranslate">YoYo Games Ltd.</span> 2022 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Room Properties
View Ports
View Cameras
-->
  <!-- TAGS
rooms_properties
-->
</body>
</html>